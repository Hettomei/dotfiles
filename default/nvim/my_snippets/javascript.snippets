snippet tc
	try {
	}${1} catch(e) {
		console.log(e);
	}
snippet cl
	console.log(${1});
snippet clt
	console.log(${1:this});
snippet json
	JSON.stringify(${1}, null, 2)
snippet /// Add TomDoc comment
	// Public: ${1:Explain what the method do}
	//
	// ${2:var1}  - ${3:Explain what the var do}
	// ${4:var2}  - ${5:Explain what the var do}
	//
	// Examples
	//
	//   multiplex("Tom", 4)
	//   # => "TomTomTomTom"
	//
	// Returns ${6:Explain what it return}
snippet /** Add big comment
	/**
	 * ${1:Explain what the method do}
	 *
	 * @param ${2:value \: String} ${3:Explain what the var do}
	 *
	 * @return ${2:value or null}
	 *
	 * Examples
	 *
	 *  valueAt({foo: { bar: '4' }}, 'foo.bar')
	 *
	 *  # => '4'
	 */
snippet jsdoc
	/**
	 * Repeat <tt>str</tt> several times.
	 * @param {string} str The string to repeat.
	 * @param {number} [times=1] How many times to repeat the string.
	 * @returns {string}
	 */
snippet bmbm Do a quick benchmarck
	const iterations = 1000
	const t0 = performance.now()
	for (let i = 0; i < iterations; i++) {
		bigMethod()
	}
	const t1 = performance.now()
	console.log('Took', (t1 - t0).toFixed(4))
snippet bmbmbm Do a quick benchmarc in nodek
	const NS_PER_SEC = 1e9;
	const iterations = 10000

	const t0 = process.hrtime()
	for (let i = 0; i < iterations; i++) {
	  OldBigMethod()
	}
	const diff1 = process.hrtime(t0);
	console.log(`OLD: ${diff1[0] + diff1[1] / NS_PER_SEC} sec`)

	const t1 = process.hrtime()
	for (let i = 0; i < iterations; i++) {
	  NewBigMethod()
	}
	const diff2 = process.hrtime(t1);
	console.log(`NEW: ${diff2[0] + diff2[1] / NS_PER_SEC} sec`)
